# wechat-api Specification

## Purpose
TBD - created by archiving change add-wechat-conversion-api. Update Purpose after archive.
## 需求
### 需求：API服务能力
系统必须为Markdown到微信公众号HTML转换提供可靠的API端点，支持POST请求处理和标准化响应返回。

#### 场景：发送有效的Markdown内容至端点
- **给定**：服务器运行正常，端点"/api/convert/wechat"已就绪
- **当**：用户发送POST请求，包含有效的Markdown文本内容
  - 请求内容类型：`application/json`
  - 请求体JSON格式正确
  - markdown字段包含有效的Markdown文本
- **那么**：服务器将响应：
  - 状态码：200 OK
  - 响应体为有效的JSON对象
  - success字段=true
  - data字段包含转换后的HTML字符串
  - meta字段包含文章元信息（如标题、作者、时间戳）

#### 场景：处理空或无效的Markdown内容
- **给定**：服务器响应请求
- **当**：请求包含空的markdown字段或格式错误时
- **那么**：服务器将响应：
  - 状态码：400 Bad Request
  - 响应体包含success=false
  - 错误对象包括错误码（"INVALID_INPUT"）和错误消息
  - 提供清晰的错误说明帮助用户修正请求

### 需求：Markdown解析能力
系统必须能够完整、准确地解析标准Markdown语法，包括基本语法元素和复杂结构性内容。

#### 场景：解析基本Markdown语法元素
- **给定**：Markdown解析器已初始化，支持CommonMark标准
- **当**：输入包含以下Markdown元素的内容时：
  - 标题1-6级（# ## ### 等）
  - 段落文本
  - 无序列表（- * +）
  - 有序列表（1. 2.）
  - 链接 [text](url)
  - 图片 ![alt](url)
  - 行内代码 `code`
  - 代码块 ```code```
  - 粗体 **text**
  - 斜体 *text*
- **那么**：解析器能够正确识别和解析所有上述元素
- **并且**：生成结构化的HTML AST表示

#### 场景：处理复杂的Markdown结构
- **当**：输入包含嵌套列表、引用块和表格等复杂结构时
- **那么**：解析器能够准确识别嵌套层级和关系
- **并且**：输出结构完整的HTML，不丢失任何元素

### 需求：样式模板应用能力
系统必须能够将转换后的Markdown内容精确匹配到微信公众号平台标准样式规范，使用提供的样式模板文件进行格式化。

#### 场景：应用标题样式
- **给定**：样式模板文件已正确加载和解析（temp\样式模板.html）
- **当**：转换后的HTML需要应用标题样式时
- **那么**：
  - H1标题应用：19.2px字体，居中对齐，底部红色边框
  - H2标题应用：19.2px字体，白色文字，红色背景，居中对齐
  - H3标题应用：17.6px字体，左侧红色边框，适度的上下间距
  - H4及以下标题应用红色样式，尺寸级联调整

#### 场景：应用段落和文本样式
- **当**：需要应用段落和文本样式时
- **那么**：
  - 段落应用：1.5em上下边距，0.1em字符间距，深灰色(#3F3F3F)
  - 列表项和列表容器适度的左边距
  - 行内代码应用：红色背景，小尺寸字体，圆角边框

#### 场景：应用特殊元素样式
- **当**：需要应用链接、引用、代码块等特殊元素样式时
- **那么**：
  - 链接应用：蓝色文字，无下划线，点击效果良好
  - 引用块应用：左侧红色边框，灰色背景，适当内边距
  - 代码块应用：深色背景，浅色文字，等宽字体，水平滚动支持

### 需求：验证与清理能力
系统必须实现严格的HTML安全验证和过滤机制，确保输出的HTML内容安全可靠，符合微信公众号平台要求。

#### 场景：过滤不安全内容
- **给定**：HTML安全过滤器已启用
- **当**：转换后的HTML包含以下不安全元素时：
  - `<script>`标签
  - `onclick`、`onload`等事件处理属性
  - `javascript:`这样的危险URL协议
  - iframe等潜在危险的嵌入标签
- **那么**：安全过滤器将：
  - 自动移除所有不安全的标签和属性
  - 保留安全的HTML标签和允许的属性
  - 确保输出的HTML符合安全白名单标准

#### 场景：验证XSS攻击尝试
- **当**：检测到潜在XSS攻击时（脚本注入、HTML标签注入等）
- **那么**：
  - 系统将拒绝处理该内容
  - 返回详细的错误响应
  - 记录安全警告信息
  - 不返回任何处理结果

### 需求：错误处理能力
系统必须提供全面的错误处理机制，能够以标准化格式返回错误信息，帮助用户快速定位和解决问题。

#### 场景：系统内部错误处理
- **给定**：服务器发生内部错误（如文件读取失败、解析错误等）
- **当**：服务器需要返回错误响应时
- **那么**：错误响应格式将标准化为：
  - HTTP状态码符合HTTP标准（如500、422等）
  - JSON对象包含success=false
  - 错误对象包含code、message和可选的details字段
  - 提供便于调试的详细错误信息（不要暴露敏感系统信息）

#### 场景：输入验证错误处理
- **当**：服务端接收到无效或格式错误的输入时
- **那么**：
  - 返回400状态码（Bad Request）
  - 错误对象中包含错误码（如"INVALID_INPUT"、"MISSING_PARAMETER"）
  - 提供清晰的错误说明，指明如何修正请求
  - 包含字段验证细节，例如哪些字段缺失或格式错误

#### 场景：请求频率限制
- **当**：用户超出请求限制时（例如每个IP每分钟最多100次请求）
- **那么**：返回429状态码（Too Many Requests）
- **并且**：响应体包含重试时间建议（Retry-After头部）

### 需求：性能与扩展能力
系统必须具备良好的性能特性，能够高效处理重复请求和大型文件，并通过缓存机制提升整体响应速度。

#### 场景：相同内容缓存
- **给定**：缓存系统已启用，且配置了适当的大小和过期时间
- **当**：发送重复的Markdown内容请求时
- **那么**：
  - 系统将首先检查缓存中是否存在相同的HTML输出
  - 如果存在，返回缓存的HTML，而不需要重新转换
  - 缓存键应基于输入内容计算得出（如内容哈希）
  - 缓存失效时自动清理和更新内容

#### 场景：大文件处理
- **当**：输入的Markdown内容超过配置的大小阈值（如5MB）时
- **那么**：
  - 系统会首先验证文件大小
  - 超限情况下返回413状态码（Payload Too Large）
  - 提供具体的文件大小限制信息
  - 提供文件压缩或分段的建议处理方案

